package controllers

import java.util.Calendar

import scala.collection.mutable.{ArrayBuffer, ListBuffer}

//import com.mongodb.casbah.commons.MongoDBObject
import play.api._
import play.api.libs.functional.syntax.unlift
import play.api.libs.json.{JsPath, Reads, Writes}
import play.api.mvc._
import play.api.mvc._
import play.api.libs.functional.syntax._
import play.api.libs.json._
import scala.collection.mutable.MutableList
import scala.collection.mutable
import scala.language.postfixOps

import com.mongodb.casbah.Imports._
import java.util.Calendar
import com.mongodb.casbah.Imports._
import com.mongodb.casbah.commons.MongoDBObject
import play.api.data.Forms._
import play.api.data._
import play.api.data.Forms.tuple
import play.api.libs.json.{JsArray, JsValue, Json}
import play.api.libs.ws.{WS, WSResponse}
import play.api.Play.current
import play.api.mvc._
import views._

import scala.collection.mutable
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, Future}
import scala.util.Properties


object Application extends Controller {


  val rechargeForm = Form(
    tuple(
      "amount" -> text,
      "password" -> text
    )
  )

  implicit val personWrites: Writes[User1] = (JsPath \ "emailId").write[String].and((JsPath \ "password").write[String])(unlift(User1.unapply))

  implicit val personReads: Reads[User1] = (
    (JsPath \ "emailId").read[String] and
      (JsPath \ "password").read[String]
    ) (User1.apply _)


  implicit val sessionReads: Reads[Sessionclass] =
    (__ \ "sessionid").read[String].map(Sessionclass)

  implicit val sessionWrites = Writes[Sessionclass]( Sessionclass =>
    JsString(Sessionclass.sessionid)
  )



  implicit val importreads: Reads[Importdata] =
    (__ \ "orgId").read[String].map(Importdata)

  implicit val importwrites = Writes[Importdata]( Importdata =>
    JsString(Importdata.orgId)
  )

  implicit val fetchuserReads: Reads[Fetchuserclass] =
    (__ \ "sessionid").read[String].map(Fetchuserclass)

  implicit val fetchuserWrites = Writes[Fetchuserclass]( Fetchuserclass =>
    JsString(Fetchuserclass.sessionid)
  )



  implicit val fetchreads: Reads[Fetchclass] = (
    (JsPath \ "firstName").read[String] and
      (JsPath \ "lastName").read[String]and
      (JsPath \ "role").read[String]and
      (JsPath \ "organization").read[String]and
      (JsPath \ "defaultPasswordFlag").read[Int]and
      (JsPath \ "orgId").read[String]and
        (JsPath \ "status").read[String]
    )(Fetchclass.apply _)

  implicit val fetchwrites: Writes[Fetchclass] = (
    (JsPath \ "firstName").write[String] and
      (JsPath \ "lastName").write[String]and
      (JsPath \ "role").write[String]and
      (JsPath \ "organization").write[String]and
      (JsPath \ "defaultPasswordFlag").write[Int]and
      (JsPath \ "orgId").write[String]and
        (JsPath \ "status").write[String]
    )(unlift(Fetchclass.unapply))





  implicit val chartreads: Reads[chartData] = (
    (JsPath \ "xaxis").read[String] and
      (JsPath \ "yaxis").read[String]and
      (JsPath \ "chartType").read[String]and
        (JsPath \ "wid").read[String]

    )(chartData.apply _)

  implicit val chartwrites: Writes[chartData] = (
    (JsPath \ "xaxis").write[String] and
      (JsPath \ "yaxis").write[String]and
      (JsPath \ "chartType").write[String]and
        (JsPath \ "wid").write[String]

    )(unlift(chartData.unapply))



  implicit val deletereads: Reads[deleteData] = (
    (JsPath \ "xaxis").read[String] and
      (JsPath \ "yaxis").read[String]and
      (JsPath \ "chartType").read[String]and
      (JsPath \ "wid").read[String]and
        (JsPath \ "email").read[String]
    )(deleteData.apply _)

  implicit val deletewrites: Writes[deleteData] = (
    (JsPath \ "xaxis").write[String] and
      (JsPath \ "yaxis").write[String]and
      (JsPath \ "chartType").write[String]and
      (JsPath \ "wid").write[String]and
        (JsPath \ "email").write[String]
    )(unlift(deleteData.unapply))




  implicit val user_registerreads: Reads[Userregister] = (
    (JsPath \ "firstName").read[String] and
      (JsPath \ "lastName").read[String]and
      (JsPath \ "emailId").read[String]and
      (JsPath \ "password").read[String]and
      (JsPath \ "role").read[String]and
      (JsPath \ "organization").read[String]
    )(Userregister.apply _)

  implicit val userwrites: Writes[Userregister] = (
    (JsPath \ "firstName").write[String] and
      (JsPath \ "lastName").write[String]and
      (JsPath \ "emailId").write[String] and
      (JsPath \ "password").write[String]and
      (JsPath \ "role").write[String]and
      (JsPath \ "organization").write[String]
    )(unlift(Userregister.unapply))

  implicit val changereads: Reads[User2] = (
    (JsPath \ "sessionId").read[String] and
      (JsPath \ "actionType").read[String] and
      (JsPath \ "oldpassword").read[String] and
      (JsPath \ "newpassword").read[String]

    ) (User2.apply _)

  implicit val changewrites: Writes[User2] = (
    (JsPath \ "emailId").write[String] and
      (JsPath \ "actionType").write[String] and
      (JsPath \ "oldpassword").write[String] and
      (JsPath \ "newpassword").write[String]

    ) (unlift(User2.unapply))



  implicit val widgetreads: Reads[Widgetdata] = (
    (JsPath \ "orgId").read[String] and
      (JsPath \ "xaxis").read[String] and
      (JsPath \ "yaxis").read[String] and
      (JsPath \ "chartType").read[String]and
        (JsPath \ "wid").read[String]

    ) (Widgetdata.apply _)

  implicit val widgetwrites: Writes[Widgetdata] = (
    (JsPath \ "orgId").write[String] and
      (JsPath \ "xaxis").write[String] and
      (JsPath \ "yaxis").write[String] and
      (JsPath \ "chartType").write[String]and
        (JsPath \ "wid").write[String]

    ) (unlift(Widgetdata.unapply))




  implicit val TransResponseWrites: Writes[TransResponse] = (JsPath \ "status").write[String].and((JsPath \ "sessionid").write[String])(unlift(TransResponse.unapply))
  implicit val TransResponseReads: Reads[TransResponse] = (JsPath \ "status").read[String].and((JsPath \ "sessionid").read[String])(TransResponse.apply _)



  //case class Order(orgId:String, item:Item)
  implicit val itemreads: Reads[Item] = (
    (__ \ "courseName").read[String] and
      (__ \ "totalClasses").read[String] and
      (__ \ "totalSemesters").read[String] and
      (__ \ "academicYear").read[String]
    )(Item.apply _)
  implicit val itemwrites: Writes[Item] = (
    (__ \ "courseName").write[String] and
      (__ \ "totalClasses").write[String] and
      (__ \ "totalSemesters").write[String] and
      (__ \ "academicYear").write[String]
    )(unlift(Item.unapply))

  implicit val itemsreads: Reads[Items] = (
    (__ \ "courseName").read[String] and
      (__ \ "totalClasses").read[String] and
      (__ \ "totalSemesters").read[String] and
      (__ \ "academicYear").read[String] and
      (__ \ "technology").read[String] and
      (__ \ "language").read[String]
    )(Items.apply _)
  implicit val itemswrites: Writes[Items] = (
    (__ \ "courseName").write[String] and
      (__ \ "totalClasses").write[String] and
      (__ \ "totalSemesters").write[String] and
      (__ \ "academicYear").write[String] and
      (__ \ "technology").write[String] and
      (__ \ "language").write[String]
    )(unlift(Items.unapply))

  implicit val yaxisread: Reads[yaxispayload] = (
    (__ \ "org_name").read[String] and
      (__ \ "course_name").read[String] and
      (__ \ "academicYear").read[String] and
      (__ \ "semester").read[String] and
      (__ \ "subject").read[String] and
      (__ \ "yaxis").read[String]
    ) (yaxispayload.apply _)
  implicit val yaxiswrite: Writes[yaxispayload] = (
    (__ \ "org_name").write[String] and
      (__ \ "course_name").write[String] and
      (__ \ "academicYear").write[String] and
      (__ \ "semester").write[String] and
      (__ \ "subject").write[String] and
      (__ \ "yaxis").write[String]
    ) (unlift(yaxispayload.unapply))


  implicit val OrderWrites: Writes[Order] = (JsPath \ "orgId").write[String].and((JsPath \ "orgName").write[String]).and((JsPath \ "dropdown").write[String]).and((JsPath \ "lengthOfCourses").write[Int])(unlift(Order.unapply))
  implicit val OrderReads: Reads[Order] = (JsPath \ "orgId").read[String].and((JsPath \ "orgName").read[String]).and((JsPath \ "dropdown").read[String]).and((JsPath \ "lengthOfCourses").read[Int])(Order.apply _)

  /*implicit val importreads: Reads[Importdata] =
    (__ \ "orgId").read[String].map(Importdata)

  implicit val importwrites = Writes[Importdata]( Importdata =>
    JsString(Importdata.orgId)
  )*/

  implicit val importStudentwrite: Writes[ImportStudent] = (JsPath \ "orgId").write[String].and((JsPath \ "org_name").write[String]).and((JsPath \ "numberOfStudents").write[Int]).and((JsPath \ "dropdown").write[String])(unlift(ImportStudent.unapply))
  implicit val importStudentread: Reads[ImportStudent] = (JsPath \ "orgId").read[String].and((JsPath \ "org_name").read[String]).and((JsPath \ "numberOfStudents").read[Int]).and((JsPath \ "dropdown").read[String])(ImportStudent.apply _)

  implicit val markswrite: Writes[Marks] = (JsPath \ "subject").write[String].and((JsPath \ "mark").write[String])(unlift(Marks.unapply))
  implicit val marksread: Reads[Marks] = (JsPath \ "subject").read[String].and((JsPath \ "mark").read[String])(Marks.apply _)

  implicit val techObjwrite: Writes[TechObj] = (JsPath \ "technology").write[String].and((JsPath \ "weightage").write[String])(unlift(TechObj.unapply))
  implicit val techObjread: Reads[TechObj] = (JsPath \ "technology").read[String].and((JsPath \ "weightage").read[String])(TechObj.apply _)

  implicit val MarksRespreads: Reads[MarksResp] = (
    (__ \ "org_name").read[String] and
      (__ \ "course_name").read[String] and
      (__ \ "academicYear").read[String] and
      (__ \ "semester").read[String] and
      (__ \ "roll_no").read[String] and
      (__ \ "marks").read[List[Marks]]
    )(MarksResp.apply _)
  implicit val MarksRespwrites: Writes[MarksResp] = (
    (__ \ "org_name").write[String] and
      (__ \ "course_name").write[String] and
      (__ \ "academicYear").write[String] and
      (__ \ "semester").write[String] and
      (__ \ "roll_no").write[String] and
      (__ \ "marks").write[List[Marks]]
    )(unlift(MarksResp.unapply))

  def all = Action {implicit request =>

    Ok(views.html.index1())
  }

  def registor = Action {implicit request =>

    Ok(views.html.index1())
  }

  def dashboard = Action {implicit request =>

    Ok(views.html.Dashboard())
  }

  def authenticate = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[User1]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = User => {
        val repository1: mutable.MutableList[User1] = new mutable.MutableList[User1]()
        val email = User.emailId
        val query = MongoDBObject("emailId" -> email)
        val col = MongoFactory.memberCollection.findOne(query)


        if (col.toString().equalsIgnoreCase("None")) {
          println("User name not exist")
          Ok("[\t{\n\t\"status\": \"fail\",\n\t\"error\": \"User name not exist\"\n}\t]").as("application/json")
        }
        else {
          println("email is valid")
          val password = col.map(_.as[String]("password").toString())
          val role1= col.map(_.as[String]("role").toString())
          val memberId= col.map(_.as[String]("memberId").toString()).get
          if (password.get.equals(User.password)) {
            //println(password.get)
            println("password is valid")
            def uuid = java.util.UUID.randomUUID().toString

            def sha1(s: String) = java.security.MessageDigest.getInstance("SHA-1").digest(s.getBytes).map((b: Byte) => (if (b >= 0 & b < 16) "0" else "") + (b & 0xFF).toHexString).mkString

            val id = sha1(uuid: String)
            val sessionToken = id.substring(0, 16)

            println("going in counter to get session id")
            val que = MongoDBObject("_id" -> "counter")
            val res = MongoFactory.counterCollection.findOne(que)
            println("hello")
            var sessioncount = res.map(_.as[Int]("sessionId")).get

           // println("hello")
            println(sessioncount)


            //split the
            val sessionid1 = "session_" + sessioncount;
            sessioncount += 1;

            val date2 = Calendar.getInstance().getTime().toString()

            val useSession= sessionauth(sessionid1,email,sessionToken,date2,memberId)
            val que1 = MongoDBObject("emailId" -> email)
            val sessiondoc = MongoFactory.sessionCollection.findOne(que1);
            if(sessiondoc.toString().equalsIgnoreCase("None"))
            {
              insert.insertingSessiondoc(useSession)
              println("session inserted")
            }
            else
            {
              val upval1 = MongoDBObject("$set" -> MongoDBObject("sessionId" ->sessionid1,"sessionToken"->sessionToken,"dateTimeStamp"->date2))
              val session_update = MongoFactory.sessionCollection.update(que1,upval1)
              println("session updated")
            }



            val upval = MongoDBObject(
              "$set" -> MongoDBObject("sessionId" ->sessioncount)
            )
            val chk = MongoFactory.counterCollection.update(que,upval)
            println("session Count increamented in counter")


            //Ok(Json.toJson(repository1)).as(JSON)

            println("Login Succesfully")
            val respo = TransResponse("Success", sessionid1)
            //val repository: mutable.MutableList[TransResponse] = new mutable.MutableList[TransResponse]()
            //repository += respo

            Ok(Json.toJson(respo)).as("application/json")

          } else {

            println("Invalid password")
            Ok("\t{\n\t\"status\": \"fail\",\n\t\"error\": \"Invalid password\"\n}\t").as("application/json")
          }


        }

      }

    )

  }
  def register = Action(BodyParsers.parse.json) { request =>
    // val repository4: mutable.MutableList[DetailsProvider] = new mutable.MutableList[DetailsProvider]()
    val either = request.body.validate[Userregister]
    either.fold(
      errors => BadRequest("invalid json"),
      Userregister => {
        val firstName1 = Userregister.firstName;
        val lastName1 = Userregister.lastName;
        val email1 = Userregister.emailId;
        val password= Userregister.password
        val role1 = Userregister.role
        val organization1 = Userregister.organization
        val   query1= MongoDBObject("emailId"->email1)
        val col = MongoFactory.memberCollection.findOne(query1)
        if(col.toString().equals("None")) {


          var passwordHistory = new ListBuffer[String]()
          passwordHistory += password

          //val passwordHistory = List()
          //passwordHistory = password;
          println(passwordHistory)
          val defaultPasswordFlag = 0



          val que = MongoDBObject("_id" -> "counter")
          val res = MongoFactory.counterCollection.findOne(que)
          var memberCount = res.map(_.as[Int]("memberId")).get
          println("memberId: " + memberCount)
          var orgIdCount = res.map(_.as[Int]("orgId")).get

          println("orgId: " + orgIdCount)

          val readonlyFlag = 0;
          val blockFlag = 0;
          val dateTimeStamp = Calendar.getInstance().getTime().toString();
          val memberidString = "member_" + memberCount.toString()
          val orgIdString = "org_" + orgIdCount.toString();
          var charts: List[chartData] =  List()

          val use1 = Userregister1(memberidString, firstName1, lastName1, email1, password, role1, organization1, orgIdString,  passwordHistory,defaultPasswordFlag, blockFlag, readonlyFlag, dateTimeStamp,charts)
          println(use1)
          insert.insertingToken(use1)

          memberCount += 1
          val upval = MongoDBObject(
            "$set" -> MongoDBObject("memberId" ->memberCount)
          )
          val chk = MongoFactory.counterCollection.update(que,upval)


          val queorg = MongoDBObject("orgId" -> orgIdString)
          val resorg = MongoFactory.orgCollection.findOne(queorg)
          println(resorg)
          //fields in orgnization collection
          val orgId = orgIdString;
          val orgName = organization1;
          //var academicYear = new Array[String](10)
          var academicYear: List[String] =  List()

          var courses: List[Item] =  List()
          //var charts: List[chartData] =  List()
          //var courses = new Array[Item](10);

          //var studentDetails =  new Array[String](10)
          var studentDetails: List[String] =  List()



          if(resorg.toString().equals("None"))
          {
            println("none")
            val dropdown = ""
            val orguser = UserOrg(orgId,orgName,academicYear,courses,studentDetails,dateTimeStamp,dropdown)
            //println(insert.insertingOrgnization(orguser))
            insert.insertingOrgnization(orguser)
            println("orgnization inserted")


            orgIdCount += 1
            val queCounter = MongoDBObject("_id" -> "counter")
            val upval = MongoDBObject(
              "$set" -> MongoDBObject("orgId" ->orgIdCount, "memberId" -> memberCount)
            )
            val chk = MongoFactory.counterCollection.update(queCounter,upval)
          }
          else
          {
              println("Orgnization documents is there for this org id")
          }



          Ok("{\n\t\"status\": \"success\",\n\t\"error\": \"user suceesfully registered\"\n}").as("application/json")
        }else{
          Ok("{\n\t\"status\": \"failure\",\n\t\"error\": \" Username already exist\"\n}").as("application/json")
        }
      }
    )
  }


  def resetPassword = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[User2]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = User2 => {
        val repository1: mutable.MutableList[User1] = new mutable.MutableList[User1]()
        val oldpassword1 = User2.oldpassword
        val newpassword1 = User2.newpassword
        val sessionId = User2.sessionId
        val actionType = User2.actionType

        val querysession = MongoDBObject("sessionId" -> sessionId)
        val colsession = MongoFactory.sessionCollection.findOne(querysession)

        if (colsession.toString().equalsIgnoreCase("None")) {

          Ok("\t{\n\t\"status\": \"fail\",\n\t\"error\": \"Invalid Session!\"\n}\t").as("application/json")
        } else {

          val email = colsession.map(_.as[String]("emailId").toString())

            val query = MongoDBObject("emailId" -> email, "password" -> oldpassword1)
            val col = MongoFactory.memberCollection.findOne(query)
            if (col.toString().equalsIgnoreCase("None")) {

              Ok("\t{\n\t\"status\": \"fail\",\n\t\"error\": \"username and password doesnot match\"\n}\t").as("application/json")
            } else {

              val query1 = MongoDBObject("passwordHistory" -> newpassword1)
              val col1 = MongoFactory.memberCollection.findOne(query1)
              println(col1)
              if (col1.toString().equalsIgnoreCase("None")) {

                val query2 = MongoDBObject("emailId" -> email)
                val col2 = MongoFactory.memberCollection.findOne(query2)
                val listOfPasswords = (col2.map(_.as[List[String]]("passwordHistory")))
                val b = (listOfPasswords.toList.head)
                val finalListofPasswords = newpassword1 :: b
                finalListofPasswords.foreach {
                  println
                }

                val upval = MongoDBObject(
                  "$set" -> MongoDBObject("passwordHistory" -> finalListofPasswords, "password" -> newpassword1, "defaultPasswordFlag" -> 1)
                )
                MongoFactory.memberCollection.update(query, upval)
                println("Password changed successfully!")
                Ok("\t{\n\t\"status\": \"success\",\n\t\"error\": \"password changed successfully\"\n}\t").as("application/json")
              } else {
                Ok("\t{\n\t\"status\": \"fail\",\n\t\"error\": \"passwordalready exist\"\n}\t").as("application/json")
              }

            }
        }


      }

    )

  }


  def sessionApi = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Sessionclass]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = Sessionclass => {


        val sessionid = Sessionclass.sessionid;
        val query = MongoDBObject("sessionId" -> sessionid)
        val col = MongoFactory.sessionCollection.findOne(query)


        if (col.toString().equalsIgnoreCase("None")) {
          println("session id Fail")
          Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No Session id Found\"\n}\t]").as("application/json")
        }
        else {
          println("session id Found")
          Ok("[\t{\n\t\"status\": \"success\"\n}\t]").as("application/json")
        }

      }
    )

  }




  def WidgetApi = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Widgetdata]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = Widgetdata => {


        val orgId = Widgetdata.orgId;
        val xaxis = Widgetdata.xaxis;
        val yaxis = Widgetdata.yaxis;
        val chartType = Widgetdata.chartType;
        val wid = Widgetdata.wid;
        val query = MongoDBObject("orgId" -> orgId)
        val col = MongoFactory.memberCollection.findOne(query)


        if (col.toString().equalsIgnoreCase("None")) {
          println("No member found Fail")
          Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No Session id Found\"\n}\t]").as("application/json")
        }
        else {
          val chartdata = chartData(xaxis,yaxis,chartType,wid)
         /* println(chartdata)
          val coursesUpdate = MongoDBObject("$set" -> MongoDBObject("charts" -> chartdata))
          println(coursesUpdate)
          MongoFactory.memberCollection.findAndModify(query,coursesUpdate)*/
         val chartsbuild = MongoDBObject.newBuilder
          chartsbuild += "xaxis" -> xaxis
          chartsbuild += "yaxis" -> yaxis
          chartsbuild += "chartType" -> chartType
          chartsbuild += "wid" -> wid

          chartsbuild.result


          /* val coursesUpdate = $push("courses" -> coursesbuild.result(),"academicYear" -> academicYear(i).as[JsString].value,"studentDetails" -> studentDetails(i).as[JsString].value)
           MongoFactory.orgCollection.findAndModify(query,coursesUpdate)*/
          val coursesUpdate = $push("charts" -> chartsbuild.result())
          MongoFactory.memberCollection.findAndModify(query,coursesUpdate)
          println("Member found for charts Found")
          Ok("[\t{\n\t\"status\": \"success\"\n}\t]").as("application/json")
        }

      }
    )

  }

  def yaxis = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[yaxispayload]
    either.fold(
      errors => BadRequest("invalid json person"),
      yaxispayload => {
        //repository.+=(person)
        val org_name1 = yaxispayload.org_name;
        val course_name = yaxispayload.course_name;
        val academicYear = yaxispayload.academicYear;
        val semester = yaxispayload.semester;
        val subject = yaxispayload.subject;
        var yaxis =  yaxispayload.yaxis;
        println(yaxis)
        val collection1 = MongoConnection()("my_scala")("marksDetails")
        var key = Array(org_name1,course_name,academicYear,semester,subject)
        val keys = "[\""+course_name.toString+"\",\""+academicYear.toString+"\",\""+semester.toString+"\",\""+subject.toString+"\"]"

        println(keys.toString)
        // ["""+course_name.toString+academicYear.toString+semester.toString+subject.toString+"""]

        val MapReduceInlineOutput = com.mongodb.casbah.map_reduce.MapReduceInlineOutput

        val mapF: JSFunction = {"""function(){var key ="""+keys.toString+""" ;var count=1;var values = {count:count};emit(key,values);}"""
          .stripMargin
        }
        println(mapF)
        val reduceF: JSFunction = { """ function(key,values){return {count:values.length};}"""
          .stripMargin
        }
        //val result = new Array[String](100)

        val result9 =  collection1.mapReduce(mapF, reduceF, MapReduceInlineOutput, Some(MongoDBObject( "org_name" -> "Terralogic")),verbose = false)
        val resultobj = result9.cursor.next();
        println(resultobj)
        val countvalue = resultobj.get("value")

        println(countvalue)
        println(result9)
        // println(result9.cursor.next())

        // ["CSE","2010-2016","5","Java"]
        val keys1 = "[\""+course_name.toString+"\",\""+academicYear.toString+"\",\""+semester.toString+"\",\""+subject.toString+"\"]"

        //[ "Number of Students in the perticular year", "Overall Average Marks parcentage on all years", "Overall pass percentage", "Overall fail percentage" ];

        val mapavg: JSFunction = {"""function(){ var mark = [];var key ="""+keys.toString+""";for(i = 0;i<this.marks.length;i++){mark.push(this.marks[i].mark);}var values = {marks: mark}; emit(key,values);}"""
          .stripMargin
        }
        println(mapavg)

        val reduceavg: JSFunction = { """ function(key,values){var noOfMark = 0;
                                        |var markper = [];
                                        |var sum = 0;
                                        |for (var i = 0; i < values.length; i++) {
                                        |  for(var j = 0;j < values[i].marks.length; j++)
                                        |   {
                                        |      markper.push(values[i].marks[j]*100/100);
                                        |                        noOfMark++;
                                        |
                                        |                }
                                        |
                                        |        }
                                        |        for(i = 0;i<markper.length;i++)
                                        |        {
                                        |                sum += markper[i]
                                        |        }
                                        |        marksParcentage = sum/noOfMark;
                                        |
                                        |
                                        |                return {marksParcentage:marksParcentage};
                                        |
                                        |        }"""
          .stripMargin
        }

        val resultavg  =  collection1.mapReduce(mapavg, reduceavg, MapReduceInlineOutput, Some(MongoDBObject( "org_name" -> org_name1 )),verbose = false)
        //println(resultavg.cursor.foreach(results))
        println(resultavg)
        val resultobj1 = resultavg.cursor.next();
        val countvalue1 = resultobj1.get("value")

        println(countvalue1)

        val mappass: JSFunction= {"""function(){var status;for(i = 0;i< this.marks.length;i++){if(this.marks[i].mark>= 50){status ="pass";}else{ status ="fail";}};var key = """+keys.toString+""";
                                                                                                                                                                                                 | var values = {academicYear: this.academicYear, semester: this.semester, subject:"Java1",statusof:status};
                                                                                                                                                                                                 | emit(key,values);
                                                                                                                                                                                                 | };"""
          .stripMargin
        }

        val reducepass : JSFunction = { """ function(key,values){var noOfMark = 0;
                                          |var markper = [];
                                          |var sum = 0;
                                          |for (var i = 0; i < values.length; i++) {
                                          |  for(var j = 0;j < values[i].marks.length; j++)
                                          |   {
                                          |      markper.push(values[i].marks[j]*100/100);
                                          |                        noOfMark++;
                                          |
                                          |                }
                                          |
                                          |        }
                                          |        for(i = 0;i<markper.length;i++)
                                          |        {
                                          |                sum += markper[i]
                                          |        }
                                          |        marksParcentage = sum/noOfMark;
                                          |
                                          |
                                          |                return {marksParcentage:marksParcentage};
                                          |
                                          |        }"""
          .stripMargin
        }




        val query = MongoDBObject("org_name" ->org_name1)
        val col = collection1.findOne(query)
        if (yaxis =="Number of Students in the perticular year") {
          val json: JsValue = Json.obj("course_name" ->course_name ,"academicYear" -> academicYear, "semester" -> semester, "subject" -> subject,"countvalue" ->countvalue.toString)
          Ok(json).as("application/json")

        } else if(yaxis == "Overall Average Marks parcentage on all years") {
          val json: JsValue = Json.obj("course_name" -> course_name, "academicYear" -> academicYear, "semester" -> semester, "subject" -> subject, "markspercentage" -> countvalue1.toString)

          Ok(json).as("application/json")

        }else if(yaxis == "Overall pass percentage"){
          val json: JsValue = Json.obj("course_name" -> course_name, "academicYear" -> academicYear, "semester" -> semester, "subject" -> subject, "countvalue" -> countvalue.toString)

          Ok(json).as("application/json")

        }else if(yaxis == "Overall pass percentage"){
          val json: JsValue = Json.obj("course_name" -> course_name, "academicYear" -> academicYear, "semester" -> semester, "subject" -> subject, "countvalue" -> countvalue.toString)

          Ok(json).as("application/json")
        }else{
          Ok("[\t{\n\t\"status\": \"Fail\"\n}\t]").as("application/json")

        }

      }
    )
  }




  /* def deleteWidgetApi = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[deleteData]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = deleteData => {

        val email = deleteData.email;
        val xaxis = deleteData.xaxis;
        val yaxis = deleteData.yaxis;
        val chartType = deleteData.chartType;
        val wid = deleteData.wid;
        val query = MongoDBObject("emailId" -> email)
        val col = MongoFactory.memberCollection.findOne(query)

        if (col.toString().equalsIgnoreCase("None")) {
          println("No member for chart found Fail")
          Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No Session id Found\"\n}\t]").as("application/json")
        }
        else {
          //var temp: List[chartData] =  List()

        var sample: List[chartData] =  List()
          val coursesbuild = MongoDBList.newBuilder

          val charts = col.map(_.as[List[chartData]]("charts")).get
          for (res <- col) {
            var memberInfo = res.getAs[MongoDBList]("charts").get
            for(i <- 0 to charts.length-1) {
              val member = memberInfo.as[BasicDBObject](i)
              // prints the individual name of the inside object
             println(member("xaxis").toString)
             // println(xaxis)
              if(member("xaxis").toString != xaxis){

                val obj: chartData = chartData(member("xaxis").toString,member("yaxis").toString,member("chartType").toString,member("wid").toString)

                sample = obj :: sample
             }
             else if(member("yaxis").toString != yaxis){

              }

            }
          }
         println(sample)

          //println(sample.length)
          val chartList = Json.toJson(sample)
          println(chartList)
          val dbList = MongoDBList(sample:_*)
          println(dbList)
         // var mem = chartList.getAs[MongoDBList]("chartList").get
          //println("SSS"+mem)
          //println(chartList.length)

         /* for (i <- 0 to chartList.length) {


            println((courses(i) \ "courseName").as[JsString].value)
            val coursesbuild = MongoDBObject.newBuilder
            coursesbuild += "courseName" -> (courses(i) \ "courseName").as[JsString].value
            coursesbuild += "totalClasses" -> (courses(i) \ "totalClasses").as[JsString].value
            coursesbuild += "totalSemesters" -> (courses(i) \ "totalSemesters").as[JsString].value
            coursesbuild += "academicYear" -> (courses(i) \ "academicYear").as[JsString].value
            coursesbuild.result


            /* val coursesUpdate = $push("courses" -> coursesbuild.result(),"academicYear" -> academicYear(i).as[JsString].value,"studentDetails" -> studentDetails(i).as[JsString].value)
             MongoFactory.orgCollection.findAndModify(query,coursesUpdate)*/
            val coursesUpdate = $push("courses" -> coursesbuild.result())
            MongoFactory.orgCollection.findAndModify(query,coursesUpdate)

            /*val coursesUpdate1 = $pop("academicYear" -> 1)
            OrgnizationDB.collection.findAndModify(query,coursesUpdate1)*/

          }*/







          // val json: JsValue = Json.obj("charts"->chartList)
          //println(json)
        /* val upval = MongoDBList
            "$set" -> MongoDBList("charts" -> chartList)

          MongoFactory.memberCollection.update(query, upval)*/
         // val chartsUpdate = $push("charts" -> sample)
         // MongoFactory.memberCollection.findAndModify(query,chartsUpdate)



          println("charts Found")
          Ok("[\t{\n\t\"status\": \"success\"\n}\t]").as("application/json")
        }

      }
    )

  }


  */






  def logoutApi = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Sessionclass]
    either.fold(
      errors => BadRequest("invalid json person"),
      Sessionclass => {
        //repository.+=(person)
        val sessionid = Sessionclass.sessionid;
        val query = MongoDBObject("sessionId" -> sessionid)
        val col = MongoFactory.sessionCollection.findOne(query)
        if(col.toString().equalsIgnoreCase("None")){
          Ok("{\n\t\"status\": \"fail\",\n\t\"error\": \"Invalid (or) expired access token\"\n}").as("application/json")
        }else{

          val query2 =MongoDBObject("sessionId" -> sessionid)
          val col2 = MongoFactory.sessionCollection.remove(query2)
          Ok("{\n\t\"status\": \"Success\",\n\t\"message\": \"Sucessfull Logged Out\"\n}").as("application/json")
        }

      }
    )
  }








  def fetchuserDetailsApi = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Fetchuserclass]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = Fetchuserclass => {

        val sessionid = Fetchuserclass.sessionid;

        val query = MongoDBObject("sessionId" -> sessionid)
        val col = MongoFactory.sessionCollection.findOne(query)


        if (col.toString().equalsIgnoreCase("None")) {
          println("session id Fail")
          Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No Session id Found\"\n}\t]").as("application/json")
        }
        else {

          val email = col.map(_.as[String]("emailId")).get
          val query = MongoDBObject("emailId" -> email)
          println(email)
          val col1 = MongoFactory.memberCollection.findOne(query)
          println(col1)

          if (col1.toString().equalsIgnoreCase("None")) {
            println("No email for session")
            Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No email id Found\"\n}\t]").as("application/json")

          }
          else {
            val firstName = col1.map(_.as[String]("firstName")).get
            val lastName = col1.map(_.as[String]("lastName")).get
            val role = col1.map(_.as[String]("role")).get
            val organization = col1.map(_.as[String]("organization")).get
            val defaultPasswordFlag = col1.map(_.as[Int]("defaultPasswordFlag")).get
            val orgId = col1.map(_.as[String]("orgId")).get
            println("User details found")
            println("user details " +firstName +";"+lastName +";"+role +";"+organization)
            val use = Fetchclass(firstName,lastName,role,organization,defaultPasswordFlag,orgId,"Success")
            println("user details " +firstName)



            var sample1: List[chartData] =  List()
            val charts = col1.map(_.as[List[chartData]]("charts")).get
            for (res <- col1) {
              var memberInfo1 = res.getAs[MongoDBList]("charts").get
              for(i <- 0 to charts.length-1) {
                val member1 = memberInfo1.as[BasicDBObject](i)
                // prints the individual name of the inside object
                println(member1("xaxis"))
                val obj: chartData = chartData(member1("xaxis").toString,member1("yaxis").toString,member1("chartType").toString,member1("wid").toString)
                sample1 = obj :: sample1
              }
            }

            println(sample1)
            val chartList = Json.toJson(sample1)



            val query = MongoDBObject("orgId" ->orgId )
            val orgdoc = MongoFactory.orgCollection.findOne(query)
            val orgName = orgdoc.map(_.as[String]("orgName")).get
            println("orgname:---  "+orgName)

            if (orgdoc.toString().equalsIgnoreCase("None")) {
              println("No orgId for member")
              Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No org id Found\",\n\t\"org\": \"No\"\n}\t]").as("application/json")

            }

            else {
              //fatching Dropdown object from org collection
              val dropdown = orgdoc.map(_.as[String]("dropdown")).get
              //val dropdownJson = Json.toJson(dropdown);
              println("dropdown== " + dropdown)

              //fatching data from technologies and language
              println("fatching data from technologies ----------------")
              val techDocu = MongoFactory.technologiescollection.find
              //var arrayTech: Array[TechObj] = new Array[TechObj](techDocu.length)
              var listTech: List[TechObj] = List()

              for (x <- techDocu) {
                var i = 0
                //println(x("Technology"))
                val technology = x("Technology").toString();
                val weightage = x("Weightage").toString();
                val techDoc = TechObj(technology, weightage)
                //arrayTech(i)=techDoc
                listTech = techDoc :: listTech
              }
              println(listTech)
              val listTechJson = Json.toJson(listTech)

              println("fatching data from Languages ----------------")
              val langDocu = MongoFactory.languagescollection.find
              //langDocu.foreach(println)
              var listLang: List[TechObj] = List()

              for (y <- langDocu) {
                var i = 0
                // println(y("Technology"))
                val technology = y("Technology").toString();
                val weightage = y("Weightage").toString();
                val techDoc = TechObj(technology, weightage)
                //arrayTech(i)=techDoc
                listLang = techDoc :: listLang
              }
              println(listLang)
              val listLangJson = Json.toJson(listLang)


              var sample: List[Item] = List()
              val courses = orgdoc.map(_.as[List[Item]]("courses")).get
              for (res <- orgdoc) {
                var memberInfo = res.getAs[MongoDBList]("courses").get
                for (i <- 0 to courses.length - 1) {
                  val member = memberInfo.as[BasicDBObject](i)
                  // prints the individual name of the inside object
                  println(member("courseName"))
                  val obj: Item = Item(member("courseName").toString, member("totalClasses").toString, member("totalSemesters").toString, member("academicYear").toString)
                  sample = obj :: sample
                }
              }

              println(sample)
              val courseList = Json.toJson(sample)

              //Nitin code for getting for marks details

              val queryOrgname = MongoDBObject("org_name" -> orgName)
              val markdoc = MongoFactory.marksDetailcollection.findOne(queryOrgname)
              if (markdoc.toString().equalsIgnoreCase("None")) {
                println("Error: Marks details is not there for this user please import student details.")
                val status = "success"
                val orgstatus = "yes"
                val json: JsValue = Json.obj("courses" -> courseList, "dashboard" -> use, "status" -> status, "org" -> orgstatus, "technology" -> listTechJson, "language" -> listLangJson, "charts" -> chartList)
                Ok(json).as("application/json")
              }
              else {
                println("markdoc: " + markdoc)
                var markList: List[Marks] = List()
                println("nnnnnnnnnnnnnnnn----: " + markdoc)
                val org_name = markdoc.map(_.as[String]("org_name")).get
                val course_name = markdoc.map(_.as[String]("course_name")).get
                val academicYear = markdoc.map(_.as[String]("academicYear")).get
                val semester = markdoc.map(_.as[String]("semester")).get
                val roll_no = markdoc.map(_.as[String]("roll_no")).get
                val marks = markdoc.map(_.as[List[Marks]]("marks")).get
                for (res <- markdoc) {
                  val marksMongoList = res.getAs[MongoDBList]("marks").get
                  for (i <- 0 to marks.length - 1) {
                    val member = marksMongoList.as[BasicDBObject](i)
                    println(member("subject"))
                    val obj: Marks = Marks(member("subject").toString, member("mark").toString)
                    markList = obj :: markList
                  }
                }

                println(markList)
                //val markListJson = Json.toJson(markList)

                val marksResp: MarksResp = MarksResp(org_name, course_name, academicYear, semester, roll_no, markList)
                val marksRespJson = Json.toJson(marksResp)

                //serilization for json


                /*implicit val anyValWriter = Writes[MarksResp] (marksResp => marksResp match {
                case org_name:String => Json.toJson(org_name)
                case course_name:MarksResp => Json.toJson(course_name)
                case academicYear:MarksResp => Json.toJson(academicYear)
                case semester:MarksResp => Json.toJson(semester)
                case roll_no:MarksResp => Json.toJson(roll_no)
                case _ => throw new RuntimeException("unserializeable type")
              })*/

                val status = "success"
                val orgstatus = "yes"
                val json: JsValue = Json.obj("courses" -> courseList, "dashboard" -> use, "status" -> status, "org" -> orgstatus, "technology" -> listTechJson, "language" -> listLangJson, "charts" -> chartList, "marksRespJson" -> marksRespJson, "dropdown" -> dropdown)
                Ok(json).as("application/json")

              }

            }
            //Ok(Json.toJson(use)).as("application/json")

          }

        }

      }
    )

  }
  def importGetData= Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Importdata]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = Importdata => {
        val orgId = Importdata.orgId;
        val query = MongoDBObject("orgId" -> orgId)
        val col = MongoFactory.orgCollection.findOne(query)
        if (col.toString().equalsIgnoreCase("None")) {
          println("organisation not found ")
          Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No organisation Found\"\n}\t]").as("application/json")
        }
        else {
          var sample: List[Item] =  List()
          val orgName = col.map(_.as[String]("orgName")).get
          val academicYear = col.map(_.as[List[String]]("academicYear")).get
          val courses = col.map(_.as[List[Item]]("courses")).get

          // Accessing the array of objects in the DB for getting the individual items , not required, just for example have done this operation

          for (res <- col) {
            var memberInfo = res.getAs[MongoDBList]("courses").get
            for(i <- 0 to courses.length-1) {
             val member = memberInfo.as[BasicDBObject](i)
              // prints the individual name of the inside object
             println(member("courseName"))
             val obj: Item = Item(member("courseName").toString,member("totalClasses").toString,member("totalSemesters").toString,member("academicYear").toString)
            sample = obj :: sample

            }
          }


          // Converting the List[Items] to json inorder to pass the response

          println(sample)
          val courseList = Json.toJson(sample)
          val studentDetails = col.map(_.as[List[String]]("studentDetails")).get
          val dateTimeStamp = col.map(_.as[String]("dateTimeStamp")).get
          val status ="success"

          // creating a json response for the output

          val json: JsValue = Json.obj("courses"->courseList, "orgName" -> orgName , "academicYear" -> academicYear,"studentDetails"->studentDetails,"dateTimeStamp"->dateTimeStamp,"status"->"success"
          )
          Ok(json).as("application/json")
        }
      }
    )
  }


  def importinsert= Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Order]
    either.fold(
      errors => BadRequest("invalid json"),
      valid = Order => {
      //  val courses = (request.body \ "courses").get

        //println(academicYear(1).get)
        //val items=Order.courses
        val lengthOfCourses = Order.lengthOfCourses
        //val lengthOfAcademicyear = Order.lengthOfAcademicyear
        //println(items)
        /*println(courses)
       // println(courses(1).get)
        //println((courses(1) \ "courseName").as[JsString].value)
        //println((courses(1) \ "totalClasses").as[JsString].value)*/
        // val items1=Order.courses
        val orgid = Order.orgId
        val orgName = Order.orgName
        val dropdown = Order.dropdown
        val query = MongoDBObject("orgId" -> orgid)
        val col = MongoFactory.orgCollection.findOne(query)
        val courses1: List[Item] =  List()
        if (col.toString().equalsIgnoreCase("None")) {
          Ok("[\t{\n\t\"status\": \"fail\",\n\t\"\": \"Invalid Organization id\"\n}\t]").as("application/json")
        }
        else {

          val upval = MongoDBObject(
            "$set" -> MongoDBObject("courses" ->courses1)
          )
          val chk = MongoFactory.orgCollection.update(query,upval)
          val  courses = (request.body \ "courses").get

          for (i <- 0 to lengthOfCourses-1) {




            println((courses(i) \ "courseName").as[JsString].value)
            val coursesbuild = MongoDBObject.newBuilder
            coursesbuild += "courseName" -> (courses(i) \ "courseName").as[JsString].value
            coursesbuild += "totalClasses" -> (courses(i) \ "totalClasses").as[JsString].value
            coursesbuild += "totalSemesters" -> (courses(i) \ "totalSemesters").as[JsString].value
            coursesbuild += "academicYear" -> (courses(i) \ "academicYear").as[JsString].value
            coursesbuild.result


            /* val coursesUpdate = $push("courses" -> coursesbuild.result(),"academicYear" -> academicYear(i).as[JsString].value,"studentDetails" -> studentDetails(i).as[JsString].value)
             MongoFactory.orgCollection.findAndModify(query,coursesUpdate)*/
            val coursesUpdate = $push("courses" -> coursesbuild.result())
            MongoFactory.orgCollection.findAndModify(query,coursesUpdate)

            /*val coursesUpdate1 = $pop("academicYear" -> 1)
            OrgnizationDB.collection.findAndModify(query,coursesUpdate1)*/

          }
          val upval1 = MongoDBObject(
            "$set" -> MongoDBObject("dropdown" -> dropdown)
          )
          val chk1 = MongoFactory.orgCollection.update(query,upval1)
          println("Imported data successfully saved in database!")

          Ok("[\t{\n\t\"status\": \"success\",\n\t\"\": \"Countervalue is updated\"\n}\t]").as("application/json")
        }
      }
    )
  }



  def importStudent= Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[ImportStudent]
    either.fold(
      errors => BadRequest("invalid json person"),

        valid = ImportStudent => {

        val orgid = ImportStudent.orgId
        val orgName = ImportStudent.org_name
        val numberOfStudents = ImportStudent.numberOfStudents
        val dropdown = ImportStudent.dropdown

        val queCounter = MongoDBObject("_id" -> "counter")
        val res = MongoFactory.counterCollection.findOne(queCounter)
        var studentIdcount = res.map(_.as[Int]("studentId")).get
        var marksIdcount = res.map(_.as[Int]("marksId")).get

        var studentId = "student_" + studentIdcount;
        println(studentId)

        var marksId = "marks_" + marksIdcount;
        println(marksId)


        val queryOrg = MongoDBObject("orgId" -> orgid)
        //println(orgid)
        val docOrg = MongoFactory.orgCollection.findOne(queryOrg)
        //println("documents: "+docOrg)

        if(docOrg.toString().equalsIgnoreCase("none"))
        {
          Ok("[\t{\n\t\"status\": \"fail\",\n\t\"massage\": \"Invalid Organization id\"\n}\t]").as("application/json")
        }
          else{

          println("inside else")
          val queryStu = MongoDBObject("studentId" -> studentId)
          val docStu = MongoFactory.studDetailCollection.findOne(queryStu)
          if(docStu.toString().equalsIgnoreCase("none")) {
            for (j <- 0 to numberOfStudents - 1)
            {
              studentIdcount += 1;
              studentId = "student_" + studentIdcount;
              println("first loop")
              val students = (request.body \ "students").get
              val roll_no = (students(j) \ "roll_no").as[JsString].value
              val student_name = (students(j) \ "student_name").as[JsString].value
              val academicYear = (students(j) \ "academicYear").as[JsString].value
              val course_name = (students(j) \ "course_name").as[JsString].value
              //val result_year = (students(j) \ "result_year").as[JsString].value
              val semester = (students(j) \ "semester").as[JsString].value
              val numberOfSubject = (students(j) \ "numberOfSubject")
              println(numberOfSubject.get)
              val marks =(students(j) \ "marks").get

              //inserting student details
              val stuModel = StudentDetails(studentId, roll_no, student_name, orgName, course_name, academicYear)
              insert.insertingStudent(stuModel)


              marksIdcount += 1;
              marksId = "marks_" + marksIdcount;

              val subject = ""
              val mark = ""
              val markss = Marks(subject, mark)

              val marksModel = MarksDetails(marksId, orgName, course_name, academicYear, semester, roll_no, markss)
              insert.insertingMarks(marksModel)

              for (i <- 0 to numberOfStudents - 1) {

                println("second loop")
                val subject = (marks(i) \ "Subject").as[JsString].value
                val mark = (marks(i) \ "Mark").as[JsString].value
                val markss = Marks(subject, mark)



                //println("hello for loop " + marksId)
                val builder = MongoDBObject.newBuilder
                builder += "subject" -> subject
                builder += "mark" -> mark
                builder
                val query = MongoDBObject("_id" -> marksId)
                val coursesUpdate = $push("marks" -> builder.result())
                MongoFactory.marksDetailcollection.findAndModify(query, coursesUpdate)

                /*val coursesUpdate1 = $pop("academicYear" -> 1)
                OrgnizationDB.collection.findAndModify(query,coursesUpdate1)*/
                val upval = MongoDBObject(
                  "$set" -> MongoDBObject("marksId" -> marksIdcount)
                )
                val chk = MongoFactory.counterCollection.update(queCounter,upval)
              } //end of inside loop


            val upval = MongoDBObject(
              "$set" -> MongoDBObject("studentId" ->studentIdcount)
            )
              val chk = MongoFactory.counterCollection.update(queCounter,upval)

            } //end of outer loop
            //println("hello")
            val upval1 = MongoDBObject(
              "$set" -> MongoDBObject("dropdown" -> dropdown)
            )
            val chk1 = MongoFactory.orgCollection.update(queryOrg,upval1)
            println("Imported data successfully saved in database!")
            Ok("[\t{\n\t\"status\": \"success\",\n\t\"massage\": \"Student details save successfully!\"\n}\t]").as("application/json")

          }
          else {
            Ok("[\t{\n\t\"status\": \"fail\",\n\t\"massage\": \"this student is already there in database\"\n}\t]").as("application/json")
          }

        }

      }
    )
  }



}


