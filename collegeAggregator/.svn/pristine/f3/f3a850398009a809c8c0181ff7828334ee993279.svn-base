package controllers

import java.util.Calendar

import scala.collection.mutable.{ArrayBuffer, ListBuffer}

//import com.mongodb.casbah.commons.MongoDBObject
import play.api._
import play.api.libs.functional.syntax.unlift
import play.api.libs.json.{JsPath, Reads, Writes}
import play.api.mvc._
import play.api.mvc._
import play.api.libs.functional.syntax._
import play.api.libs.json._
import scala.collection.mutable.MutableList
import scala.collection.mutable
import scala.language.postfixOps

import com.mongodb.casbah.Imports._
import java.util.Calendar
import com.mongodb.casbah.Imports._
import com.mongodb.casbah.commons.MongoDBObject
import play.api.data.Forms._
import play.api.data._
import play.api.data.Forms.tuple
import play.api.libs.json.{JsArray, JsValue, Json}
import play.api.libs.ws.{WS, WSResponse}
import play.api.Play.current
import play.api.mvc._
import views._

import scala.collection.mutable
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, Future}
import scala.util.Properties


object Application extends Controller {


  val rechargeForm = Form(
    tuple(
      "amount" -> text,
      "password" -> text
    )
  )

  implicit val personWrites: Writes[User1] = (JsPath \ "emailId").write[String].and((JsPath \ "password").write[String])(unlift(User1.unapply))

  implicit val personReads: Reads[User1] = (
    (JsPath \ "emailId").read[String] and
      (JsPath \ "password").read[String]
    ) (User1.apply _)


  implicit val sessionReads: Reads[Sessionclass] =
    (__ \ "sessionid").read[String].map(Sessionclass)

  implicit val sessionWrites = Writes[Sessionclass]( Sessionclass =>
    JsString(Sessionclass.sessionid)
  )



  implicit val importreads: Reads[Importdata] =
    (__ \ "orgId").read[String].map(Importdata)

  implicit val importwrites = Writes[Importdata]( Importdata =>
    JsString(Importdata.orgId)
  )

  implicit val fetchuserReads: Reads[Fetchuserclass] =
    (__ \ "sessionid").read[String].map(Fetchuserclass)

  implicit val fetchuserWrites = Writes[Fetchuserclass]( Fetchuserclass =>
    JsString(Fetchuserclass.sessionid)
  )



  implicit val fetchreads: Reads[Fetchclass] = (
    (JsPath \ "firstName").read[String] and
      (JsPath \ "lastName").read[String]and
      (JsPath \ "role").read[String]and
      (JsPath \ "organization").read[String]and
      (JsPath \ "defaultPasswordFlag").read[Int]and
      (JsPath \ "orgId").read[String]and
        (JsPath \ "status").read[String]
    )(Fetchclass.apply _)

  implicit val fetchwrites: Writes[Fetchclass] = (
    (JsPath \ "firstName").write[String] and
      (JsPath \ "lastName").write[String]and
      (JsPath \ "role").write[String]and
      (JsPath \ "organization").write[String]and
      (JsPath \ "defaultPasswordFlag").write[Int]and
      (JsPath \ "orgId").write[String]and
        (JsPath \ "status").write[String]
    )(unlift(Fetchclass.unapply))





  implicit val chartreads: Reads[chartData] = (
    (JsPath \ "xaxis").read[String] and
      (JsPath \ "yaxis").read[String]and
      (JsPath \ "chartType").read[String]and
        (JsPath \ "wid").read[String]

    )(chartData.apply _)

  implicit val chartwrites: Writes[chartData] = (
    (JsPath \ "xaxis").write[String] and
      (JsPath \ "yaxis").write[String]and
      (JsPath \ "chartType").write[String]and
        (JsPath \ "wid").write[String]

    )(unlift(chartData.unapply))



  implicit val deletereads: Reads[deleteData] = (
    (JsPath \ "xaxis").read[String] and
      (JsPath \ "yaxis").read[String]and
      (JsPath \ "chartType").read[String]and
      (JsPath \ "wid").read[String]and
        (JsPath \ "email").read[String]
    )(deleteData.apply _)

  implicit val deletewrites: Writes[deleteData] = (
    (JsPath \ "xaxis").write[String] and
      (JsPath \ "yaxis").write[String]and
      (JsPath \ "chartType").write[String]and
      (JsPath \ "wid").write[String]and
        (JsPath \ "email").write[String]
    )(unlift(deleteData.unapply))




  implicit val user_registerreads: Reads[Userregister] = (
    (JsPath \ "firstName").read[String] and
      (JsPath \ "lastName").read[String]and
      (JsPath \ "emailId").read[String]and
      (JsPath \ "password").read[String]and
      (JsPath \ "role").read[String]and
      (JsPath \ "organization").read[String]
    )(Userregister.apply _)

  implicit val userwrites: Writes[Userregister] = (
    (JsPath \ "firstName").write[String] and
      (JsPath \ "lastName").write[String]and
      (JsPath \ "emailId").write[String] and
      (JsPath \ "password").write[String]and
      (JsPath \ "role").write[String]and
      (JsPath \ "organization").write[String]
    )(unlift(Userregister.unapply))

  implicit val changereads: Reads[User2] = (
    (JsPath \ "sessionId").read[String] and
      (JsPath \ "actionType").read[String] and
      (JsPath \ "oldpassword").read[String] and
      (JsPath \ "newpassword").read[String]

    ) (User2.apply _)

  implicit val changewrites: Writes[User2] = (
    (JsPath \ "emailId").write[String] and
      (JsPath \ "actionType").write[String] and
      (JsPath \ "oldpassword").write[String] and
      (JsPath \ "newpassword").write[String]

    ) (unlift(User2.unapply))



  implicit val widgetreads: Reads[Widgetdata] = (
    (JsPath \ "orgId").read[String] and
      (JsPath \ "xaxis").read[String] and
      (JsPath \ "yaxis").read[String] and
      (JsPath \ "chartType").read[String]and
        (JsPath \ "wid").read[String]

    ) (Widgetdata.apply _)

  implicit val widgetwrites: Writes[Widgetdata] = (
    (JsPath \ "orgId").write[String] and
      (JsPath \ "xaxis").write[String] and
      (JsPath \ "yaxis").write[String] and
      (JsPath \ "chartType").write[String]and
        (JsPath \ "wid").write[String]

    ) (unlift(Widgetdata.unapply))




  implicit val TransResponseWrites: Writes[TransResponse] = (JsPath \ "status").write[String].and((JsPath \ "sessionid").write[String])(unlift(TransResponse.unapply))
  implicit val TransResponseReads: Reads[TransResponse] = (JsPath \ "status").read[String].and((JsPath \ "sessionid").read[String])(TransResponse.apply _)



  //case class Order(orgId:String, item:Item)
  implicit val itemreads: Reads[Item] = (
    (__ \ "courseName").read[String] and
      (__ \ "totalClasses").read[String] and
      (__ \ "totalSemesters").read[String] and
      (__ \ "academicYear").read[String]
    )(Item.apply _)
  implicit val itemwrites: Writes[Item] = (
    (__ \ "courseName").write[String] and
      (__ \ "totalClasses").write[String] and
      (__ \ "totalSemesters").write[String] and
      (__ \ "academicYear").write[String]
    )(unlift(Item.unapply))

  implicit val itemsreads: Reads[Items] = (
    (__ \ "courseName").read[String] and
      (__ \ "totalClasses").read[String] and
      (__ \ "totalSemesters").read[String] and
      (__ \ "academicYear").read[String] and
      (__ \ "technology").read[String] and
      (__ \ "language").read[String]
    )(Items.apply _)
  implicit val itemswrites: Writes[Items] = (
    (__ \ "courseName").write[String] and
      (__ \ "totalClasses").write[String] and
      (__ \ "totalSemesters").write[String] and
      (__ \ "academicYear").write[String] and
      (__ \ "technology").write[String] and
      (__ \ "language").write[String]
    )(unlift(Items.unapply))


  implicit val OrderWrites: Writes[Order] = (JsPath \ "orgId").write[String].and((JsPath \ "lengthOfCourses").write[Int])(unlift(Order.unapply))
  implicit val OrderReads: Reads[Order] = (JsPath \ "orgId").read[String].and((JsPath \ "lengthOfCourses").read[Int])(Order.apply _)

  /*implicit val importreads: Reads[Importdata] =
    (__ \ "orgId").read[String].map(Importdata)

  implicit val importwrites = Writes[Importdata]( Importdata =>
    JsString(Importdata.orgId)
  )*/

  implicit val importStudentwrite: Writes[ImportStudent] = (JsPath \ "orgId").write[String].and((JsPath \ "org_name").write[String]).and((JsPath \ "numberOfStudents").write[Int])(unlift(ImportStudent.unapply))
  implicit val importStudentread: Reads[ImportStudent] = (JsPath \ "orgId").read[String].and((JsPath \ "org_name").read[String]).and((JsPath \ "numberOfStudents").read[Int])(ImportStudent.apply _)

  implicit val markswrite: Writes[Marks] = (JsPath \ "subject").write[String].and((JsPath \ "mark").write[String])(unlift(Marks.unapply))
  implicit val marksread: Reads[Marks] = (JsPath \ "subject").read[String].and((JsPath \ "mark").read[String])(Marks.apply _)

  implicit val techObjwrite: Writes[TechObj] = (JsPath \ "technology").write[String].and((JsPath \ "weightage").write[String])(unlift(TechObj.unapply))
  implicit val techObjread: Reads[TechObj] = (JsPath \ "technology").read[String].and((JsPath \ "weightage").read[String])(TechObj.apply _)

  implicit val MarksRespreads: Reads[MarksResp] = (
    (__ \ "org_name").read[String] and
      (__ \ "course_name").read[String] and
      (__ \ "academicYear").read[String] and
      (__ \ "semester").read[String] and
      (__ \ "roll_no").read[String] and
      (__ \ "marks").read[List[Marks]]
    )(MarksResp.apply _)
  implicit val MarksRespwrites: Writes[MarksResp] = (
    (__ \ "org_name").write[String] and
      (__ \ "course_name").write[String] and
      (__ \ "academicYear").write[String] and
      (__ \ "semester").write[String] and
      (__ \ "roll_no").write[String] and
      (__ \ "marks").write[List[Marks]]
    )(unlift(MarksResp.unapply))

  implicit val saveorgreads: Reads[Saveorg] = (
    (__ \ "orgId").read[String] and
      (__ \ "orgName").read[String] and
      (__ \ "dropdown").read[String]
    )(Saveorg.apply _)
  implicit val saveorgwrites: Writes[Saveorg] = (
    (__ \ "orgId").write[String] and
      (__ \ "orgName").write[String] and
      (__ \ "dropdown").write[String]
    )(unlift(Saveorg.unapply))

  def all = Action {implicit request =>

    Ok(views.html.index1())
  }

  def registor = Action {implicit request =>

    Ok(views.html.index1())
  }

  def dashboard = Action {implicit request =>

    Ok(views.html.Dashboard())
  }

  def authenticate = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[User1]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = User => {
        val repository1: mutable.MutableList[User1] = new mutable.MutableList[User1]()
        val email = User.emailId
        val query = MongoDBObject("emailId" -> email)
        val col = MongoFactory.memberCollection.findOne(query)


        if (col.toString().equalsIgnoreCase("None")) {
          println("User name not exist")
          Ok("[\t{\n\t\"status\": \"fail\",\n\t\"error\": \"User name not exist\"\n}\t]").as("application/json")
        }
        else {
          println("email is valid")
          val password = col.map(_.as[String]("password").toString())
          val role1= col.map(_.as[String]("role").toString())
          val memberId= col.map(_.as[String]("memberId").toString()).get
          if (password.get.equals(User.password)) {
            //println(password.get)
            println("password is valid")
            def uuid = java.util.UUID.randomUUID().toString

            def sha1(s: String) = java.security.MessageDigest.getInstance("SHA-1").digest(s.getBytes).map((b: Byte) => (if (b >= 0 & b < 16) "0" else "") + (b & 0xFF).toHexString).mkString

            val id = sha1(uuid: String)
            val sessionToken = id.substring(0, 16)

            println("going in counter to get session id")
            val que = MongoDBObject("_id" -> "counter")
            val res = MongoFactory.counterCollection.findOne(que)
            println("hello")
            var sessioncount = res.map(_.as[Int]("sessionId")).get

           // println("hello")
            println(sessioncount)


            //split the
            val sessionid1 = "session_" + sessioncount;
            sessioncount += 1;

            val date2 = Calendar.getInstance().getTime().toString()

            val useSession= sessionauth(sessionid1,email,sessionToken,date2,memberId)
            val que1 = MongoDBObject("emailId" -> email)
            val sessiondoc = MongoFactory.sessionCollection.findOne(que1);
            if(sessiondoc.toString().equalsIgnoreCase("None"))
            {
              insert.insertingSessiondoc(useSession)
              println("session inserted")
            }
            else
            {
              val upval1 = MongoDBObject("$set" -> MongoDBObject("sessionId" ->sessionid1,"sessionToken"->sessionToken,"dateTimeStamp"->date2))
              val session_update = MongoFactory.sessionCollection.update(que1,upval1)
              println("session updated")
            }



            val upval = MongoDBObject(
              "$set" -> MongoDBObject("sessionId" ->sessioncount)
            )
            val chk = MongoFactory.counterCollection.update(que,upval)
            println("session Count increamented in counter")


            //Ok(Json.toJson(repository1)).as(JSON)

            println("Login Succesfully")
            val respo = TransResponse("Success", sessionid1)
            //val repository: mutable.MutableList[TransResponse] = new mutable.MutableList[TransResponse]()
            //repository += respo

            Ok(Json.toJson(respo)).as("application/json")

          } else {

            println("Invalid password")
            Ok("\t{\n\t\"status\": \"fail\",\n\t\"error\": \"Invalid password\"\n}\t").as("application/json")
          }


        }

      }

    )

  }
  def register = Action(BodyParsers.parse.json) { request =>
    // val repository4: mutable.MutableList[DetailsProvider] = new mutable.MutableList[DetailsProvider]()
    val either = request.body.validate[Userregister]
    either.fold(
      errors => BadRequest("invalid json"),
      Userregister => {
        val firstName1 = Userregister.firstName;
        val lastName1 = Userregister.lastName;
        val email1 = Userregister.emailId;
        val password= Userregister.password
        val role1 = Userregister.role
        val organization1 = Userregister.organization
        val   query1= MongoDBObject("emailId"->email1)
        val col = MongoFactory.memberCollection.findOne(query1)
        if(col.toString().equals("None")) {


          var passwordHistory = new ListBuffer[String]()
          passwordHistory += password

          //val passwordHistory = List()
          //passwordHistory = password;
          println(passwordHistory)
          val defaultPasswordFlag = 0



          val que = MongoDBObject("_id" -> "counter")
          val res = MongoFactory.counterCollection.findOne(que)
          var memberCount = res.map(_.as[Int]("memberId")).get
          println("memberId: " + memberCount)
          var orgIdCount = res.map(_.as[Int]("orgId")).get

          println("orgId: " + orgIdCount)

          val readonlyFlag = 0;
          val blockFlag = 0;
          val dateTimeStamp = Calendar.getInstance().getTime().toString();
          val memberidString = "member_" + memberCount.toString()
          val orgIdString = "org_" + orgIdCount.toString();
          var charts: List[chartData] =  List()

          val use1 = Userregister1(memberidString, firstName1, lastName1, email1, password, role1, organization1, orgIdString,  passwordHistory,defaultPasswordFlag, blockFlag, readonlyFlag, dateTimeStamp,charts)
          println(use1)
          insert.insertingToken(use1)

          memberCount += 1
          val upval = MongoDBObject(
            "$set" -> MongoDBObject("memberId" ->memberCount)
          )
          val chk = MongoFactory.counterCollection.update(que,upval)


          val queorg = MongoDBObject("orgId" -> orgIdString)
          val resorg = MongoFactory.orgCollection.findOne(queorg)
          println(resorg)
          //fields in orgnization collection
          val orgId = orgIdString;
          val orgName = organization1;

          /*var academicYear: List[String] =  List()

          var courses: List[Item] =  List()

          var studentDetails: List[String] =  List()*/




          if(resorg.toString().equals("None"))
          {
            println("none")
            /*val orguser = UserOrg(orgId,orgName,academicYear,courses,studentDetails,dateTimeStamp)
            println(insert.insertingOrgnization(orguser))*/
            /*var acc_year = Acc_year()
            var semesters = Semesters()
            var course = Course()
            var subjects = Subjects()
            var dropdown = Dropdown(acc_year,semesters,course,subjects)*/
            var dropdown = "";
            val orguser = DropdownObject(orgId,orgName,dropdown)


            insert.insertingOrgnization(orguser)
            println("orgnization inserted")


            orgIdCount += 1
            val queCounter = MongoDBObject("_id" -> "counter")
            val upval = MongoDBObject(
              "$set" -> MongoDBObject("orgId" ->orgIdCount, "memberId" -> memberCount)
            )
            val chk = MongoFactory.counterCollection.update(queCounter,upval)
          }
          else
          {
              println("Orgnization documents is there for this org id")
          }



          Ok("{\n\t\"status\": \"success\",\n\t\"error\": \"user suceesfully registered\"\n}").as("application/json")
        }else{
          Ok("{\n\t\"status\": \"failure\",\n\t\"error\": \" Username already exist\"\n}").as("application/json")
        }
      }
    )
  }


  def resetPassword = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[User2]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = User2 => {
        val repository1: mutable.MutableList[User1] = new mutable.MutableList[User1]()
        val oldpassword1 = User2.oldpassword
        val newpassword1 = User2.newpassword
        val sessionId = User2.sessionId
        val actionType = User2.actionType

        val querysession = MongoDBObject("sessionId" -> sessionId)
        val colsession = MongoFactory.sessionCollection.findOne(querysession)

        if (colsession.toString().equalsIgnoreCase("None")) {

          Ok("\t{\n\t\"status\": \"fail\",\n\t\"error\": \"Invalid Session!\"\n}\t").as("application/json")
        } else {

          val email = colsession.map(_.as[String]("emailId").toString())

            val query = MongoDBObject("emailId" -> email, "password" -> oldpassword1)
            val col = MongoFactory.memberCollection.findOne(query)
            if (col.toString().equalsIgnoreCase("None")) {

              Ok("\t{\n\t\"status\": \"fail\",\n\t\"error\": \"username and password doesnot match\"\n}\t").as("application/json")
            } else {

              val query1 = MongoDBObject("passwordHistory" -> newpassword1)
              val col1 = MongoFactory.memberCollection.findOne(query1)
              println(col1)
              if (col1.toString().equalsIgnoreCase("None")) {

                val query2 = MongoDBObject("emailId" -> email)
                val col2 = MongoFactory.memberCollection.findOne(query2)
                val listOfPasswords = (col2.map(_.as[List[String]]("passwordHistory")))
                val b = (listOfPasswords.toList.head)
                val finalListofPasswords = newpassword1 :: b
                finalListofPasswords.foreach {
                  println
                }

                val upval = MongoDBObject(
                  "$set" -> MongoDBObject("passwordHistory" -> finalListofPasswords, "password" -> newpassword1, "defaultPasswordFlag" -> 1)
                )
                MongoFactory.memberCollection.update(query, upval)
                println("Password changed successfully!")
                Ok("\t{\n\t\"status\": \"success\",\n\t\"error\": \"password changed successfully\"\n}\t").as("application/json")
              } else {
                Ok("\t{\n\t\"status\": \"fail\",\n\t\"error\": \"passwordalready exist\"\n}\t").as("application/json")
              }

            }
        }


      }

    )

  }


  def sessionApi = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Sessionclass]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = Sessionclass => {


        val sessionid = Sessionclass.sessionid;
        val query = MongoDBObject("sessionId" -> sessionid)
        val col = MongoFactory.sessionCollection.findOne(query)


        if (col.toString().equalsIgnoreCase("None")) {
          println("session id Fail")
          Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No Session id Found\"\n}\t]").as("application/json")
        }
        else {
          println("session id Found")
          Ok("[\t{\n\t\"status\": \"success\"\n}\t]").as("application/json")
        }

      }
    )

  }




  def WidgetApi = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Widgetdata]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = Widgetdata => {


        val orgId = Widgetdata.orgId;
        val xaxis = Widgetdata.xaxis;
        val yaxis = Widgetdata.yaxis;
        val chartType = Widgetdata.chartType;
        val wid = Widgetdata.wid;
        val query = MongoDBObject("orgId" -> orgId)
        val col = MongoFactory.memberCollection.findOne(query)


        if (col.toString().equalsIgnoreCase("None")) {
          println("No member found Fail")
          Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No Session id Found\"\n}\t]").as("application/json")
        }
        else {
          val chartdata = chartData(xaxis,yaxis,chartType,wid)
         /* println(chartdata)
          val coursesUpdate = MongoDBObject("$set" -> MongoDBObject("charts" -> chartdata))
          println(coursesUpdate)
          MongoFactory.memberCollection.findAndModify(query,coursesUpdate)*/
         val chartsbuild = MongoDBObject.newBuilder
          chartsbuild += "xaxis" -> xaxis
          chartsbuild += "yaxis" -> yaxis
          chartsbuild += "chartType" -> chartType
          chartsbuild += "wid" -> wid

          chartsbuild.result


          /* val coursesUpdate = $push("courses" -> coursesbuild.result(),"academicYear" -> academicYear(i).as[JsString].value,"studentDetails" -> studentDetails(i).as[JsString].value)
           MongoFactory.orgCollection.findAndModify(query,coursesUpdate)*/
          val coursesUpdate = $push("charts" -> chartsbuild.result())
          MongoFactory.memberCollection.findAndModify(query,coursesUpdate)
          println("Member found for charts Found")
          Ok("[\t{\n\t\"status\": \"success\"\n}\t]").as("application/json")
        }

      }
    )

  }




  /* def deleteWidgetApi = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[deleteData]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = deleteData => {

        val email = deleteData.email;
        val xaxis = deleteData.xaxis;
        val yaxis = deleteData.yaxis;
        val chartType = deleteData.chartType;
        val wid = deleteData.wid;
        val query = MongoDBObject("emailId" -> email)
        val col = MongoFactory.memberCollection.findOne(query)

        if (col.toString().equalsIgnoreCase("None")) {
          println("No member for chart found Fail")
          Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No Session id Found\"\n}\t]").as("application/json")
        }
        else {
          //var temp: List[chartData] =  List()

        var sample: List[chartData] =  List()
          val coursesbuild = MongoDBList.newBuilder

          val charts = col.map(_.as[List[chartData]]("charts")).get
          for (res <- col) {
            var memberInfo = res.getAs[MongoDBList]("charts").get
            for(i <- 0 to charts.length-1) {
              val member = memberInfo.as[BasicDBObject](i)
              // prints the individual name of the inside object
             println(member("xaxis").toString)
             // println(xaxis)
              if(member("xaxis").toString != xaxis){

                val obj: chartData = chartData(member("xaxis").toString,member("yaxis").toString,member("chartType").toString,member("wid").toString)

                sample = obj :: sample
             }
             else if(member("yaxis").toString != yaxis){

              }

            }
          }
         println(sample)

          //println(sample.length)
          val chartList = Json.toJson(sample)
          println(chartList)
          val dbList = MongoDBList(sample:_*)
          println(dbList)
         // var mem = chartList.getAs[MongoDBList]("chartList").get
          //println("SSS"+mem)
          //println(chartList.length)

         /* for (i <- 0 to chartList.length) {


            println((courses(i) \ "courseName").as[JsString].value)
            val coursesbuild = MongoDBObject.newBuilder
            coursesbuild += "courseName" -> (courses(i) \ "courseName").as[JsString].value
            coursesbuild += "totalClasses" -> (courses(i) \ "totalClasses").as[JsString].value
            coursesbuild += "totalSemesters" -> (courses(i) \ "totalSemesters").as[JsString].value
            coursesbuild += "academicYear" -> (courses(i) \ "academicYear").as[JsString].value
            coursesbuild.result


            /* val coursesUpdate = $push("courses" -> coursesbuild.result(),"academicYear" -> academicYear(i).as[JsString].value,"studentDetails" -> studentDetails(i).as[JsString].value)
             MongoFactory.orgCollection.findAndModify(query,coursesUpdate)*/
            val coursesUpdate = $push("courses" -> coursesbuild.result())
            MongoFactory.orgCollection.findAndModify(query,coursesUpdate)

            /*val coursesUpdate1 = $pop("academicYear" -> 1)
            OrgnizationDB.collection.findAndModify(query,coursesUpdate1)*/

          }*/







          // val json: JsValue = Json.obj("charts"->chartList)
          //println(json)
        /* val upval = MongoDBList
            "$set" -> MongoDBList("charts" -> chartList)

          MongoFactory.memberCollection.update(query, upval)*/
         // val chartsUpdate = $push("charts" -> sample)
         // MongoFactory.memberCollection.findAndModify(query,chartsUpdate)



          println("charts Found")
          Ok("[\t{\n\t\"status\": \"success\"\n}\t]").as("application/json")
        }

      }
    )

  }


  */






  def logoutApi = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Sessionclass]
    either.fold(
      errors => BadRequest("invalid json person"),
      Sessionclass => {
        //repository.+=(person)
        val sessionid = Sessionclass.sessionid;
        val query = MongoDBObject("sessionId" -> sessionid)
        val col = MongoFactory.sessionCollection.findOne(query)
        if(col.toString().equalsIgnoreCase("None")){
          Ok("{\n\t\"status\": \"fail\",\n\t\"error\": \"Invalid (or) expired access token\"\n}").as("application/json")
        }else{

          val query2 =MongoDBObject("sessionId" -> sessionid)
          val col2 = MongoFactory.sessionCollection.remove(query2)
          Ok("{\n\t\"status\": \"Success\",\n\t\"message\": \"Sucessfull Logged Out\"\n}").as("application/json")
        }

      }
    )
  }








  def fetchuserDetailsApi = Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Fetchuserclass]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = Fetchuserclass => {

        val sessionid = Fetchuserclass.sessionid;

        val query = MongoDBObject("sessionId" -> sessionid)
        val col = MongoFactory.sessionCollection.findOne(query)


        if (col.toString().equalsIgnoreCase("None")) {
          println("session id Fail")
          Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No Session id Found\"\n}\t]").as("application/json")
        }
        else {

          val email = col.map(_.as[String]("emailId")).get
          val query = MongoDBObject("emailId" -> email)
          println(email)
          val col1 = MongoFactory.memberCollection.findOne(query)
          println(col1)

          if (col1.toString().equalsIgnoreCase("None")) {
            println("No email for session")
            Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No email id Found\"\n}\t]").as("application/json")

          }
          else {
            val firstName = col1.map(_.as[String]("firstName")).get
            val lastName = col1.map(_.as[String]("lastName")).get
            val role = col1.map(_.as[String]("role")).get
            println("role: "+ role)
            val organization = col1.map(_.as[String]("organization")).get
            val defaultPasswordFlag = col1.map(_.as[Int]("defaultPasswordFlag")).get
            val orgId = col1.map(_.as[String]("orgId")).get
            println("User details found")
            println("user details " +firstName +";"+lastName +";"+role +";"+organization)
            val use = Fetchclass(firstName,lastName,role,organization,defaultPasswordFlag,orgId,"Success")
            println("user details " +firstName)



            var sample1: List[chartData] =  List()
            val charts = col1.map(_.as[List[chartData]]("charts")).get
            for (res <- col1) {
              var memberInfo1 = res.getAs[MongoDBList]("charts").get
              for(i <- 0 to charts.length-1) {
                val member1 = memberInfo1.as[BasicDBObject](i)
                // prints the individual name of the inside object
                println(member1("xaxis"))
                val obj: chartData = chartData(member1("xaxis").toString,member1("yaxis").toString,member1("chartType").toString,member1("wid").toString)
                sample1 = obj :: sample1
              }
            }

            println(sample1)
            val chartList = Json.toJson(sample1)



            val query = MongoDBObject("orgId" ->orgId )
            val orgdoc = MongoFactory.orgCollection.findOne(query)
            val orgName = orgdoc.map(_.as[String]("orgName")).get
            println("orgname:---  "+orgName)

            if (orgdoc.toString().equalsIgnoreCase("None")) {
              println("No orgId for member")
              Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No org id Found\",\n\t\"org\": \"No\"\n}\t]").as("application/json")

            }

            else {

              //fatching Dropdown object from org collection
              val dropdown = orgdoc.map(_.as[String]("dropdown")).get
              println("dropdown== " + dropdown)


              //fatching data from technologies and language
              println("fatching data from technologies ----------------")
              val techDocu = MongoFactory.technologiescollection.find
              //var arrayTech: Array[TechObj] = new Array[TechObj](techDocu.length)
              var listTech: List[TechObj] = List()

              for (x <- techDocu) {
                var i = 0
                //println(x("Technology"))
                val technology = x("Technology").toString();
                val weightage = x("Weightage").toString();
                val techDoc = TechObj(technology, weightage)
                //arrayTech(i)=techDoc
                listTech = techDoc :: listTech
              }
              println(listTech)
              val listTechJson = Json.toJson(listTech)

              println("fatching data from Languages ----------------")
              val langDocu = MongoFactory.languagescollection.find
              //langDocu.foreach(println)
              var listLang: List[TechObj] = List()

              for (y <- langDocu) {
                var i = 0
                // println(y("Technology"))
                val technology = y("Technology").toString();
                val weightage = y("Weightage").toString();
                val techDoc = TechObj(technology, weightage)
                //arrayTech(i)=techDoc
                listLang = techDoc :: listLang
              }
              println(listLang)
              val listLangJson = Json.toJson(listLang)

//Nitin code for getting for marks details(commented for now)
              /*var sample: List[Item] = List()
              val courses = orgdoc.map(_.as[List[Item]]("courses")).get
              for (res <- orgdoc) {
                var memberInfo = res.getAs[MongoDBList]("courses").get
                for (i <- 0 to courses.length - 1) {
                  val member = memberInfo.as[BasicDBObject](i)
                  // prints the individual name of the inside object
                  println(member("courseName"))
                  val obj: Item = Item(member("courseName").toString, member("totalClasses").toString, member("totalSemesters").toString, member("academicYear").toString)
                  sample = obj :: sample
                }
              }

              println(sample)
              val courseList = Json.toJson(sample)



              val queryOrgname = MongoDBObject("org_name" -> orgName)
              val markdoc = MongoFactory.marksDetailcollection.findOne(queryOrgname)
              if (markdoc.toString().equalsIgnoreCase("None")) {
                println("Error: Marks details is not there for this user please import student details.")
                val status = "success"
                val orgstatus = "yes"
                val json: JsValue = Json.obj("courses" -> courseList, "dashboard" -> use, "status" -> status, "org" -> orgstatus, "technology" -> listTechJson, "language" -> listLangJson, "charts" -> chartList)
                Ok(json).as("application/json")
              }
              else {
                println("markdoc: " + markdoc)
                var markList: List[Marks] = List()
                println("nnnnnnnnnnnnnnnn----: " + markdoc)
                val org_name = markdoc.map(_.as[String]("org_name")).get
                val course_name = markdoc.map(_.as[String]("course_name")).get
                val academicYear = markdoc.map(_.as[String]("academicYear")).get
                val semester = markdoc.map(_.as[String]("semester")).get
                val roll_no = markdoc.map(_.as[String]("roll_no")).get
                val marks = markdoc.map(_.as[List[Marks]]("marks")).get
                for (res <- markdoc) {
                  val marksMongoList = res.getAs[MongoDBList]("marks").get
                  for (i <- 0 to marks.length - 1) {
                    val member = marksMongoList.as[BasicDBObject](i)
                    println(member("subject"))
                    val obj: Marks = Marks(member("subject").toString, member("mark").toString)
                    markList = obj :: markList
                  }
                }

                println(markList)
                //val markListJson = Json.toJson(markList)

                val marksResp: MarksResp = MarksResp(org_name, course_name, academicYear, semester, roll_no, markList)
                val marksRespJson = Json.toJson(marksResp)

                //serilization for json


                /*implicit val anyValWriter = Writes[MarksResp] (marksResp => marksResp match {
                case org_name:String => Json.toJson(org_name)
                case course_name:MarksResp => Json.toJson(course_name)
                case academicYear:MarksResp => Json.toJson(academicYear)
                case semester:MarksResp => Json.toJson(semester)
                case roll_no:MarksResp => Json.toJson(roll_no)
                case _ => throw new RuntimeException("unserializeable type")
              })*/

                val status = "success"
                val orgstatus = "yes"
                val json: JsValue = Json.obj("courses" -> courseList, "dashboard" -> use, "status" -> status, "org" -> orgstatus, "technology" -> listTechJson, "language" -> listLangJson, "charts" -> chartList, "marksRespJson" -> marksRespJson)
                Ok(json).as("application/json")

              }*/

              val status = "success"
              val orgstatus = "yes"
              val json: JsValue = Json.obj("dashboard" -> use, "status" -> status, "org" -> orgstatus, "technology" -> listTechJson, "language" -> listLangJson, "charts" -> chartList, "dropdown" -> dropdown)
              Ok(json).as("application/json")
            }
            //Ok(Json.toJson(use)).as("application/json")

          }

        }

      }
    )

  }
  def importGetData= Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Importdata]
    either.fold(
      errors => BadRequest("invalid json person"),
      valid = Importdata => {
        val orgId = Importdata.orgId;
        val query = MongoDBObject("orgId" -> orgId)
        val col = MongoFactory.orgCollection.findOne(query)
        if (col.toString().equalsIgnoreCase("None")) {
          println("organisation not found ")
          Ok("[\t{\n\t\"status\": \"Fail\",\n\t\"error\": \"No organisation Found\"\n}\t]").as("application/json")
        }
        else {
          var sample: List[Item] =  List()
          val orgName = col.map(_.as[String]("orgName")).get
          val academicYear = col.map(_.as[List[String]]("academicYear")).get
          val courses = col.map(_.as[List[Item]]("courses")).get

          // Accessing the array of objects in the DB for getting the individual items , not required, just for example have done this operation

          for (res <- col) {
            var memberInfo = res.getAs[MongoDBList]("courses").get
            for(i <- 0 to courses.length-1) {
             val member = memberInfo.as[BasicDBObject](i)
              // prints the individual name of the inside object
             println(member("courseName"))
             val obj: Item = Item(member("courseName").toString,member("totalClasses").toString,member("totalSemesters").toString,member("academicYear").toString)
            sample = obj :: sample

            }
          }


          // Converting the List[Items] to json inorder to pass the response

          println(sample)
          val courseList = Json.toJson(sample)
          val studentDetails = col.map(_.as[List[String]]("studentDetails")).get
          val dateTimeStamp = col.map(_.as[String]("dateTimeStamp")).get
          val status ="success"

          // creating a json response for the output

          val json: JsValue = Json.obj("courses"->courseList, "orgName" -> orgName , "academicYear" -> academicYear,"studentDetails"->studentDetails,"dateTimeStamp"->dateTimeStamp,"status"->"success"
          )
          Ok(json).as("application/json")
        }
      }
    )
  }


  def importinsert= Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Order]
    either.fold(
      errors => BadRequest("invalid json"),
      valid = Order => {
      //  val courses = (request.body \ "courses").get

        //println(academicYear(1).get)
        //val items=Order.courses
        val lengthOfCourses = Order.lengthOfCourses
        //val lengthOfAcademicyear = Order.lengthOfAcademicyear
        //println(items)
        /*println(courses)
       // println(courses(1).get)
        //println((courses(1) \ "courseName").as[JsString].value)
        //println((courses(1) \ "totalClasses").as[JsString].value)*/
        // val items1=Order.courses
        val orgid = Order.orgId
        val query = MongoDBObject("orgId" -> orgid)
        val col = MongoFactory.orgCollection.findOne(query)
        val courses1: List[Item] =  List()
        if (col.toString().equalsIgnoreCase("None")) {
          Ok("[\t{\n\t\"status\": \"fail\",\n\t\"\": \"Invalid Organization id\"\n}\t]").as("application/json")
        }
        else {

          val upval = MongoDBObject(
            "$set" -> MongoDBObject("courses" ->courses1)
          )
          val chk = MongoFactory.orgCollection.update(query,upval)
          val  courses = (request.body \ "courses").get

          for (i <- 0 to lengthOfCourses-1) {




            println((courses(i) \ "courseName").as[JsString].value)
            val coursesbuild = MongoDBObject.newBuilder
            coursesbuild += "courseName" -> (courses(i) \ "courseName").as[JsString].value
            coursesbuild += "totalClasses" -> (courses(i) \ "totalClasses").as[JsString].value
            coursesbuild += "totalSemesters" -> (courses(i) \ "totalSemesters").as[JsString].value
            coursesbuild += "academicYear" -> (courses(i) \ "academicYear").as[JsString].value
            coursesbuild.result


            /* val coursesUpdate = $push("courses" -> coursesbuild.result(),"academicYear" -> academicYear(i).as[JsString].value,"studentDetails" -> studentDetails(i).as[JsString].value)
             MongoFactory.orgCollection.findAndModify(query,coursesUpdate)*/
            val coursesUpdate = $push("courses" -> coursesbuild.result())
            MongoFactory.orgCollection.findAndModify(query,coursesUpdate)

            /*val coursesUpdate1 = $pop("academicYear" -> 1)
            OrgnizationDB.collection.findAndModify(query,coursesUpdate1)*/

          }


          Ok("[\t{\n\t\"status\": \"success\",\n\t\"\": \"Countervalue is updated\"\n}\t]").as("application/json")
        }
      }
    )
  }



  def importStudent= Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[ImportStudent]
    either.fold(
      errors => BadRequest("invalid json person"),

        valid = ImportStudent => {

        val orgid = ImportStudent.orgId
        val orgName = ImportStudent.org_name
        val numberOfStudents = ImportStudent.numberOfStudents


        val queCounter = MongoDBObject("_id" -> "counter")
        val res = MongoFactory.counterCollection.findOne(queCounter)
        var studentIdcount = res.map(_.as[Int]("studentId")).get
        var marksIdcount = res.map(_.as[Int]("marksId")).get

        var studentId = "student_" + studentIdcount;
        //println(studentId)

        var marksId = "marks_" + marksIdcount;
        //println(marksId)


        val queryOrg = MongoDBObject("orgId" -> orgid)
        //println(orgid)
        val docOrg = MongoFactory.orgCollection.findOne(queryOrg)
        //println("documents: "+docOrg)

        if(docOrg.toString().equalsIgnoreCase("none"))
        {
          Ok("[\t{\n\t\"status\": \"fail\",\n\t\"massage\": \"Invalid Organization id\"\n}\t]").as("application/json")
        }
          else{

          println("inside else")
          val queryStu = MongoDBObject("studentId" -> studentId)
          val docStu = MongoFactory.studDetailCollection.findOne(queryStu)
          if(docStu.toString().equalsIgnoreCase("none")) {
            for (j <- 0 to numberOfStudents - 1)
            {
              studentIdcount += 1;
              studentId = "student_" + studentIdcount;
              println("first loop")
              val students = (request.body \ "students").get
              val roll_no = (students(j) \ "roll_no").as[JsString].value
              val student_name = (students(j) \ "student_name").as[JsString].value
              val academicYear = (students(j) \ "academicYear").as[JsString].value
              val course_name = (students(j) \ "course_name").as[JsString].value
              //val result_year = (students(j) \ "result_year").as[JsString].value
              val semester = (students(j) \ "semester").as[JsString].value
              val numberOfSubject = (students(j) \ "numberOfSubject")
              println(numberOfSubject.get)
              val marks =(students(j) \ "marks").get

              //inserting student details
              val stuModel = StudentDetails(studentId, roll_no, student_name, orgName, course_name, academicYear)
              insert.insertingStudent(stuModel)




              for (i <- 0 to numberOfStudents - 1) {
                marksIdcount += 1;
                marksId = "marks_" + marksIdcount;
                println("second loop")
                val subject = (marks(i) \ "Subject").as[JsString].value
                val mark = (marks(i) \ "Mark").as[JsString].value
                val markss = Marks(subject, mark)

                val marksModel = MarksDetails(marksId, orgName, course_name, academicYear, semester, roll_no, markss)
                insert.insertingMarks(marksModel)

                //println("hello for loop " + marksId)
                val builder = MongoDBObject.newBuilder
                builder += "subject" -> subject
                builder += "mark" -> mark
                builder
                val query = MongoDBObject("_id" -> marksId)
                val coursesUpdate = $push("marks" -> builder.result())
                MongoFactory.marksDetailcollection.findAndModify(query, coursesUpdate)

                /*val coursesUpdate1 = $pop("academicYear" -> 1)
                OrgnizationDB.collection.findAndModify(query,coursesUpdate1)*/
                val upval = MongoDBObject(
                  "$set" -> MongoDBObject("marksId" -> marksIdcount)
                )
                val chk = MongoFactory.counterCollection.update(queCounter,upval)
              } //end of inside loop
            val upval = MongoDBObject(
              "$set" -> MongoDBObject("studentId" ->studentIdcount)
            )
              val chk = MongoFactory.counterCollection.update(queCounter,upval)

            } //end of outer loop
            //println("hello")
            Ok("[\t{\n\t\"status\": \"success\",\n\t\"massage\": \"Student details save successfully!\"\n}\t]").as("application/json")

          }
          else {
            Ok("[\t{\n\t\"status\": \"fail\",\n\t\"massage\": \"this student is already there in database\"\n}\t]").as("application/json")
          }

        }

      }
    )
  }

  def saveOrg= Action(BodyParsers.parse.json) { request =>
    val either = request.body.validate[Saveorg]
    either.fold(
      errors => BadRequest("invalid json"),
      valid = Saveorg => {
        var orgId = Saveorg.orgId;
        var orgName = Saveorg.orgName;
        var dropdown = Saveorg.dropdown;
        val query = MongoDBObject("orgId" -> orgId)
        val orgDoc = MongoFactory.orgCollection.findOne(query)
        println("importOrg")

        if (orgDoc.toString().equalsIgnoreCase("None")) {
          Ok("[\t{\n\t\"status\": \"fail\",\n\t\"\": \"Invalid Organization id\"\n}\t]").as("application/json")
        }
        else {
          val upval = MongoDBObject(
            "$set" -> MongoDBObject("dropdown" -> dropdown)
          )
          val chk = MongoFactory.orgCollection.update(query,upval)
          println("Imported data successfully saved in database!")
          Ok("[\t{\n\t\"status\": \"success\",\n\t\"\": \"Imported data successfully saved in database\"\n}\t]").as("application/json")
        }

      }
    )
  }

}


